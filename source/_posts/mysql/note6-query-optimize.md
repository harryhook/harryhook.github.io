---
title: MySQL 查询过程及优化
date: 2020-03-08 16:29:26
tags: [MySQL]
categories: [数据库]
---

MySQL 查询过程一共分几步？

<!--more-->


# MySQL 查询基础

查询过程分为以下五步：

1. 客户端发送查询指令给服务器
2. 服务器先查询缓存， 如果命中缓存立刻返回缓存中的结果。否则下一阶段
3. 服务器对查询语句进行 SQL 解析、预处理， 再由优化器生成响应的执行计划
4. MySQL 根据优化器生成执行计划， 调用存储引擎层的 api 来执行查询
5. 将查询结果返回给客户端 

![查询执行路径](query_path.jpeg)

## 客户端/服务端间的通信协议
客户端与服务端之间是“半双工”， 一端发送数据时，另一端只能接收。 一般来说服务端返回的数据很大， 客户端完整的接收数据需要花费很长的时间， 所以必要的时候需要对查询增加 LIMIT 限制。

## 查询缓存

在解析 sql 语句之前， 如果缓存是打开的， MySQL 会优先检查是否命中缓存中的数据， 如果命中了数据， 返回结果前还要验证一次用户权限， 权限没有问题会直接返回缓存中查得的数据。

## 查询优化处理
查询优化包含多个子阶段： 解析 sql， 预处理， 优化 sql 执行计划。

### 语法解析器与预处理
MySQL 通过关键字对 SQL 语句进行解析， 生成一颗解析树。在这一步解析器将验证关键字是否正确， 关键字的顺序是否正确， 还会验证引号是否前后正确匹配。

### 查询优化器
此时语法树是合法的，优化器会将其转化成执行计划， 一条语句可能由多种执行方式，优化器的作用就是找到其中最好的的执行计划。 查询优化可以简单分为两种：静态优化和动态优化。 静态优化对解析树进行分析，例如通过简单的代数变换将 WHERE 条件转换成另一种形式，第一次完成后一直有效， 不受参数变化的影响； 动态优化与查询的上下文有关， 比如 WHERE 条件的取值、索引中条目对应的数据行等， 每次查询都需重新评估。

以下是 MySQL 可以优化的类型：

* 重新定义关联表的顺序
* 将外连接转化成内链接
* 使用等价变换原则
* 优化 COUNT(), MAX(), MIN()
* 预估并转化为常数表达式
* 覆盖索引扫描
* 子查询优化
* 提前终止查询
* 等值传播
* 列表 IN() 的比较

### 数据和索引的统计信息
大多数情况下，数据和索引的统计信息都在存储引擎层维护。

### 关联查询
MySQL 关联 查询时先将子查询的结果放到一个临时表中， 将临时表也当做一个普通表对待。MySQL 先将一系列的查询结果放到一个临时表中，然后再嵌套循环到下一个表中寻找匹配的行， 直到找到所有的匹配行为止。

### 执行计划
MySQL 的执行计划从一个表开始嵌套循环、回溯完成所有表的关联。

![多表关联](join.jpg)

### 关联查询优化器
关联优化查询器通过评估不同顺序的成本选择一个代价最小的关联顺序。

### 排序优化
当不能只有索引生成的排序结果时， MySQL 需要自己进行排序。如果数据量小可以在内存中排序， 数据量大时在磁盘中排序， 两种情况统称为文件排序(file sort)， 有以下2种排序规则：
* 两次传输排序： 需要读取两次数据表， 成本高， 旧版本使用
* 单次传输排序： 先从数据表读取所有列， 再排序， 直接返回排序结果

file sort 带来的问题是有可能排序产生的临时表比磁盘的原有文件还要大， 所以查看EXPLAIN 时如果出现 "Using temporary; Using filesort"时需要留意。

## 查询执行引擎
在解析和优化阶段， MySQL 将生成查询对应的执行计划。 查询过程中每个表对应一个 handler， 存储引擎提供查询的接口供优化器使用， 这些接口包含获取表的相关信息， 表的列名、索引统计信息等。

## 返回结果给客户端

如果查询的结果可以被缓存， MySQL 会将查得的结果缓存起来。

MySQL 返回结果的过程并不是一次将所有结果返回， 而是一个逐步的过程， 以关联表为例， 处理器在处理完最后一个关联表生成第一条结果时就开始向客户端返回数据了。

这样服务单无需存储太多的结果，也不会因为返回太多结果而占销毁太多内存。

# 要想查询速度快不要做哪些

## 查询了不需要的数据

### 查询了不需要的数据

可以在查询条件中新增 LIMIT ， 返回自己需要的条数。

### 多表关联时返回全部的列

```
SELECT * FROM A
INNER JOIN B 
INNER JOIN C
WHERE XXX;
```
这样的操作会返回 A、B、C 的全部列。 正确的做法是只取需要的列：
```
SELECT A.* FROM A
INNER JOIN B 
INNER JOIN C
WHERE XXX;
```

### 总是取出全部列

禁止使用 SELECT * 。 使用 SELECT * 查询会带来额外的 I/O、内存和 CPU 的消耗。

### 重复查询相同的数据

如果重复执行相同的查询， 并总是返回完全相同的数据。 对这些很少发生变化的数据， 将它缓存起来。

## 是否扫描了额外的记录

衡量指标：
* 响应时间： 服务时间 + 阻塞时间

    服务时间指的是数据库处理查询花费的时间；
    阻塞时间指的是服务器在等待资源过程中花的时间， I/O 操作、行锁等
    
* 扫描的行数

    理想情况下扫描的行数应该和返回的行数相同。
    
* 扫描的类型

    访问的类型有： 全表扫描(ALL)、索引扫描(ref)、范围扫描(range)、唯一索引(unique)、常数引用(const)。 速度依次由慢到快

MySQL 会在以下三种情况使用 WHERE 条件：

* 在索引中使用 WHERE 条件过滤不匹配的记录， 属于存储引擎层的操作；
* 索引覆盖扫描（无需回表)返回记录， 从索引中过滤不需要的记录并返回名字的结果， 属于服务器层操作；
* 从数据表中返回数据， 过滤不满足条件的记录。

如果发现查询需要扫描大量的数据但只返回了少数的行， 可以尝试以下操作优化：
* 使用索引覆盖扫描， 无需回表；
* 改变库表结果， 使用单独的汇总表；
* 重写复杂的查询， 让 MySQL 更优地处理。


# 重构查询方式以提升查询效率

将查询进行转换， 可以使得返回同样的结果，但是速度更快。

## 使用一个复杂查询还是多个简单查询

MySQL 的连接和端口的开销很小， 所以对 MySQL 来说网络通信、查询解析和优化的成本比以前小了很多。 有必要时将浮躁查询分解成多个查询。

## 切分查询

将一个大查询切分成小查询， 每个小查询只完成一小部分， 返回一小部分结果。

批量删除旧数据， 每次限制 10000 条数据。

## 拆分关联查询

对关联查询进行分解， 将分解得到的数据在应用层或者说在内存中进行处理。

```java
SELECT * FROM tag
    JOIN tag_post on tag_post.tag_id = tag.id
    JOIN post on tag_post.post_id = post.id
where tag.tag = 'mysql';

-- 分解成如下：
SELECT * FROM tag WHERE tag = 'mysql';
SELECT * FROM tag_post WHERE tag_id= 1234;
SELECT * FROM post WHERE post_id in (123, 456, 789, 0992)';
```

这样做的好处是：

* 让缓存效率更高。分解后的语句查询的结果更容易被缓存， 而联表查询的零时表缓存的命中率并不高？（因为关联的一张表发生变化就会导致缓存失效）；
* 查询分解， 减少锁竞争；
* 应用层关联， 利于数据库的拆分， 扩展性更高；
* 查询效率更高， 使用 in 操作可以让查询按 ID 顺序查询。
