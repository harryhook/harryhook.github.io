---
title: MySQL架构与历史
date: 2020-02-08 12:03:43
tags: [MySQL]
categories: [数据库]
---

常说的ACID与MySQL的隔离级别到底是怎么回事？
<!--more-->

# MySQL的主要特征
最主要的特征莫过于**存储引擎**， 存储引擎将查询处理、其他系统任务和数据的读写相分离；

# MySQL架构(三层结构)
既然MySQL这么厉害， 那到底什么是存储引擎， 要搞明白存储引擎， 我们先看下MySQL的架构， 以及存储引擎在MySQL中所处什么位置，到底做了什么。
 
 MySQL按结构划分分为三层：
 
	第一层：面向客户端的连接层;
	第二层：大多数MySQL核心功能所在的中间层，具有查询解析、优化、缓存、内置函数等功能;
	第三层：存储引擎，负责数据的存储与提取
	
如图所示：

![MySQL架构](mysql架构.jpg)

由这个架构可以看到， 存储引擎相当于是数据与文件系统的接口（桥梁），中间层将SQL语句解析后判断需要执行什么操作，调用存储引擎的接口， 通过存储引擎将数据存储到文件系统中或将数据从文件系统中取出。


# 并发控制

 当面临多个读写操作是， MySQL是如何做读写控制？
 >	读操作共享数据单元，加读锁（共享锁）， 读锁不会阻塞其他的读操作， 但是会阻塞写操作；写操作时加**排他锁**， 会阻塞其他的读锁和写锁。

 锁的粒度如何？ 表锁、行锁又有什么区别？
 >  表锁是开销最小的策略， 当写数据时， 会先获得写锁，同时会阻塞其他用户对改表的所有读写操作；当没有人获得写锁时， 多个读锁间不会相互阻塞，此时可以有多个事务进行读操作。
 > 行锁最大程度支持并发， 但也带来了最大的开销。只在引擎层做了实现， 没有在服务层实现
 
 
# 事务特性（ACID)

以转账为例:

	开启事务:
	
		查询账户a余额 = 500;
	
		从a账户-200， a账户余额= 300;
		
		给b账户+200；
		
	提交事务;
		
转账过程中的任何一步出错， 之前的所有步骤都应该回退， 否则可能a的账户中少了300， 但b账户未到账
 
其中ACID 的含义如下：

* **Atomicity**（原子性）：一个事务必须视为不可分割的最小单元， 要么全部成功， 要么全部失败， 以上面转账为例， 不能缺省中间的任何一个步骤， 否则全部失败。

* **Consistency**（一致性）： 数据库从一个一致性的状态转换到另一个一致性的状态， 事务未提交之前， a、b账户的金额都是不会变的。

* **Isolation**（隔离性）：一个事务的修改在提交之前， 对其他事务是不可见的。例如在转账的事务未提交之前， 另一个转账事务开始时，看到a账户的金额的金额应该是500才对。

* **Durability**（隔离性）：一旦事务提交，其所作的修改会永久保存到数据库中。

# 事务的隔离级别

MySQL定义了四种隔离级别，但是这四种隔离级别到底是怎么来的？ 先看下官方的定义

* **READ UNCOMMITED** （未提交读）: MySQL中最低的隔离级别， 即使事务中的修改没有提交， 也可以被其他事务看见。 事务可以读取未提交的数据， 也被称之为脏读（Dirty Read）, 在实际应用中很少使用。

* **READ COMMITED** (提交读)： 大多数数据库的默认隔离级别， 但MySQL不是。一个事务只能看到已提交的事务所做的修改， 反过来说， 一个事务在提交前， 所做的任何修改对其他事务都是不可见的。因为这种隔离级别可能导致**同样的查询会读到两个不一样的结果**， 称之为不可重复读（nonrepeatable read）；

*  **REPEATABLE READ**（可重复读）：MySQL中InnoDB引擎的默认隔离级别，该级别解决了不可重复读的问题（这里有个疑问是如何做到的？）， 但是解决不了幻读（Phantom Read），所谓幻读， 事务在进行范围查询时， 另一个事务在该范围内插入了新纪录， 实际应用中InnoDB 通过间隙锁（范围锁定）来解决幻读问题；

* **SERIALIZABLE**（可串行化）：强制事务串行执行， 可以避免幻读问题，为读取的每一行数据都加锁， 但是会导致大量的超时和锁竞争， 很少使用。

其实隔离级别的实现跟锁是密不可分的， 举个例子先看下没锁会导致什么情况

![无锁](无锁.jpeg)

* a.旺财和小强同时对一个账号进行操作，都读取到A=100， 旺财对账号+20， 余额为120； 小强也对余额100处理， 对将账号减去50，余额等于50， 覆盖了旺财的结果， 可以看出无锁的情况会造成数据丢失。

* b.此后旺财和小强约定对写操作加锁（排它锁, X锁）， 只能有一方对数据进行写， 解决了两个人同时修改数据导致的问题， 但是这样带来了一个新的问题（**脏数据**），如下图所示：

![脏数据](脏数据.jpeg)

当旺财进行写操作时， 账号余额变成了120， 此时小强对余额进行读取拿到结果120， 但是旺财的系统出现问题进行了回滚， 余额又回滚到了100， 此时小强就读到了脏数据。 *脏数据出现的原因是事务中没有提交的数据对其他事务可见导致的*。

* c.针对脏数据的问题， 旺财和小强约定在读数据的时候加读锁（共享锁, S锁）， 共享锁不会阻塞其他读操作，写操作时会阻塞其他的读、写操作；加了X锁，就不能获取S锁，加了S锁就不能获取X锁， 但加了S锁还可以获取S锁。

![不可重复读](不可重复读.jpeg)

旺财分别对A、B加上S锁，读取完毕后释放S锁 ， 计算C=A+B，；小强获取B的X锁， 执行B=B-30；释放B的X锁； 此时旺财再执行（在一个事务中）刚才的查询发现前后两次C计算的结果不一样， 导致了**不可重复读的问题**。

* d.旺财和小强约定， S锁不能读完数据就立马释放， 需要持续到事务提交； 再面对上面这种情况时，B获取X锁就会失败。

![可重复读](可重复读.jpeg)

当旺财再计算C=A+B时， 先对A、B加S锁， 读取完毕S锁也不会释放；此时小强再获取X锁就会失败，这样就能够避免重复读取数据时出现数据不一致的情况了， 这里就对应了**可重复读**。

* e. 有一次旺财对一批学生进行了批量处理， 选取了age=18的数据， 处理完后发现有一行竟然是没处理的数据, 查了半天才发现， 在旺财查询修改数据期间，小强也新增了一条数据，正是新增的这条数据让旺财产生了幻觉。 为了解决这种问题， 旺财和小强决定串行执行， 这里就对应了**串行化**。

# 死锁问题
两个或多个事务对同一资源的抢占，并请求锁定对方的资源；

	事务1：
		START TRANSACTION;
		UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = '2020-02-08';
		UPDATE StockPrice SET close = 45.50 WHERE stock_id = 3 and date = '2020-02-09';
		COMMIT;
		
	事务2：
		START TRANSACTION;
		UPDATE StockPrice SET close = 45.50 WHERE stock_id = 3 and date = '2020-02-09';
		UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = '2020-02-08';
		COMMIT;
		
如果两个事务通知执行第一条UPDATE语句，更新了该行数据，同时对改行数据进行锁定； 

当执行到第二条UPDATE语句时，事务1需要获得stock_id = 3的写锁， 事务2需要stock_id = 4的写锁， 然而这两个写锁都被对方占有，两个事务都等对方释放锁， 此时就造成了死锁。

解决死锁的方法：
	* 超时解除; 
	* 最少行级别的排他锁（写锁）进行回滚。
	
# 事务日志
通过事务日志， 存储引擎先将数据在内存中进行修改， 然后再持久化到硬盘中的事务日志， 不用每次都写进硬盘； 就算系统奔溃， 在重启时也会恢复修改的数据。
两次写操作， 修改数据需要写两次硬盘； 

# 混合事务与显示锁定

MySQL采用的是自动提交模式，默认每个查询都会开启事务； 如果关闭自动提交， 需要显式commit或者rollback结束一个事务， 此间的所有查询都在一个事务中。

不推荐在事务中混合事务引擎和非事务引擎， 当数据需要回滚时， 非事务引擎数据无法回滚， 会造成数据的非一致性

InnoDB采用的是两阶段锁（疑问： 什么是两阶段锁， 在哪两阶段）：事务在执行过程中随时都可以锁定， 只有在commit或者rollback后锁才会释放，其中 select … for update 就是显式锁定

此外不要使用AUTOCOMMIT 以及LOCK TABLES ， 性能太差

# MVCC 多版本控制（MVCC算法）
MVCC是行级锁的一个变种， 相比于行级锁性能更高一些， 避免了很多加锁操作， 开销更低； 
实现原理：为每行数据赋予一个版本号， 每次修改数据都会版本号+1， 读取数据时开启事务，给当前事务一个版本号a， 查询数据库中版本号<=当前版本号a的数据， 就算此时新增了数据，版本号为b， 此时b>a， 在之前的查询事务中继续查询， 得到的数据是没有发生变化的）。 以REPEATABLE READ为例：

    SELECT :
	    a. InnoDB 会查找当前事务版本号之前（小于等于当前版本号的）的数据行；
	    b. 行的删除版本号要么未定义， 要么大于当前版本号。这样可以确保事务读取到的行在事务开始前未被删除

    INSERT: 为新插入的每一行保存当前版本号作为行版本号

    DELETE： 为删除的每一行保存当前版本号作为行版本号

    UPDATE:  先新增一行数据，保存当前事务版本号作为行版本号， 再将当前版本行作为之前数据的行删除标识（先增后删）
    
MVCC只在REPEATABLE READ 和 READ COMMITED下工作， READ UNCOMMITED总是读取最新的数据行， SERIALIZABLE对每行数据都加锁

# 存储引擎

InnoDB, MyisAM为官方引擎， 第三方还有XtraDB等

InnoDB 特性：

* 采用MVCC支持高并发， 实现了四个标准的隔离级别， 默认REPEATABLE READ, 通过间隙锁防止幻读出现
* InnoDB基于聚簇索引， 使得主键查询的性能很高
* InnoDB 内部做了优化， 从磁盘读取数据是采用可预测性读， 读操作的自适应哈希索引， 写操作的插入缓存区


MyISAM特性：全文索引， 压缩， 空间函数(GIS), 不足： 不支持事务和行级锁， 崩溃后无法恢复

* 加锁与并发， 对整张表加锁，对需要读取的所有表加共享锁， 写入时加排他锁，  这里引入了一个概念叫做并发插入（读操作的同时， 往表中写数据）

* 修复： 这里的修复和崩溃后恢复不是一个概念，执行CHECK TABLE table_name 后有错误时再REPAIR TABLE table_name

* 索引特性：支持全文索引， 对于BLOB, TEXT等长字段， 也可以基于前500个字符创建索引； 如果设置了延迟更新索引建DELAY_KEY_WRITE， 每次修改完成后不会立即将修改的索引写入磁盘，而是先写入内存的缓存区

* 可压缩：对于不再修改的内容可以进行压缩


# 如何选择合适的引擎(尽量不要使用混合引擎)

事务支持：InnoDB, XtraDB, 不需要事务支持时MyISAM
备份：在线备份InnoDB 首选， 定期关闭服务器备份无论哪种引擎都可以
崩溃恢复： InnoDB 首选， MyISAM损坏概率更改， 切恢复速度更慢， 这都是相比于InnoDB来说的
特性： MyISAM的GIS， 支持地理空间搜索

# 转换引擎： 常见的三种方法
**ALTER TABLE**:   ALTER TABLE table_name ENGINE = InnoDB;
    该方法适用于任何引擎， 但是执行时间很长， 原理是将原表复制到一张新表中，复制期间会对原表加锁， 而且会丢失原引擎的特性， 例如InnoDB转换到MyISAM再转回InnoDB时会丢失外键索引。
    
**导出与导入**：利用MySQLdump 导出到文件， 修改MySQL文件中create table  的引擎选项， 同时修改表名。

**创建与查询：**结合第一种方法的高效（相比于导出）和第二种安全（相比于1）特性。

	1.先创建一张空表  	 CREATE TEBLE innodb_table Like myisam_table;
	2.再修改引擎	 	 ALTER TABLE innodb_table ENGINE = InnoDB;
	3.最后复制数据    	 INSERT INTO innodb_table SELECT * FROM myisam_table;
	

 参考：  [码农翻身](https://mp.weixin.qq.com/s/bM_g6Z0K93DNFycvfJIbwQ)
  
